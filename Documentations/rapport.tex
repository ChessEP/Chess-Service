%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     STYLE POUR LES EXPOSES TECHNIQUES 
%         3e année INSA de Rennes
%
%             NE PAS MODIFIER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,11pt]{article}

\usepackage{exptech}       % Fichier (./exptech.sty) contenant les styles pour 
                           % l'expose technique (ne pas le modifier)

%\linespread{1,6}          % Pour une version destinée à un relecteur,
                           % décommenter cette commande (double interligne) 
                           
% UTILISEZ SPELL (correcteur orthographique) à accès simplifié depuis XEmacs

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{ \textbf{Distributed Chess Service} }
\markright{Distributed Chess Service} 
                           % Pour avoir le titre de l'expose sur chaque page

\author{Paul \textsc{Chaignon}, Thomas \textsc{François}, \\
        Damien \textsc{Le Guen}, Clément \textsc{Gautrais}, \\
				Benoit \textsc{Travers} \\
        \\
        Encadrant : Yann \textsc{Ricquebourg}}

\date{}                    % Ne pas modifier
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}          

\maketitle                 % Génère le titre
\thispagestyle{empty}      % Supprime le numéro de page sur la 1re page



\begin{abstract}


Le résumé est limité à 10 lignes au maximum.
\end{abstract} 


\section{Introduction}  
L'objectif de cette étude pratique était de oeuvre une chorégraphie de services web utilisant les réponses de services spécialisés pour proposer un coup sélectionné comme étant le meilleur dans une position donnée. De plus, Loïc Héloüet, à l'origine de ce sujet sera amené ensuite à reprendre notre système. Nous devions donc lui fournir des outils bien documentés et facilement réutilisables.

L'un des souhaits de Loïc Héloüet était d'utiliser REST (REpresentational State Transfer \cite{rest-fielding}) comme style d'architecture. REST est un style d'architecture associant à une url un objet. De plus REST utilise un nombre réduit de méthode pour interagir avec ces objets. Les quatres actions de bases CRUD (Create, Read, Update et Delete) sont effectuées respectivement par des méthodes HTTP (POST, GET, PUT et DELETE).

En plus d'avoir une architecture respectant le style REST, les données échangées étaient elles-mêmes bien spécifiques. En effet, les échecs utilisent des notations définies suivant des normes reconnues pour représenter un plateau de jeu et un coup joué. Ces normes sont d'ailleurs utilisées par tous les services spécialisés (appelés ressources par la suite). La notation la plus utilisé pour représenter un plateau de jeu est la FEN (Forsyth-Edwards Notation). Elle décrit le plateau ligne par ligne de façon compacte et elle contient d'autres informations (nombre de coups, couleur ayant joué), pour certaines spécifiques aux règles du jeu d'échecs (roque, en passant). Les coups sont eux représentés suivant une notation principale : la notation algébrique. Elle consiste généralement à donner la case de départ et la case d'arrivée (cette notation est appelée LAN (Long Algebraic Notation), mais dans certaines configuration de jeu, seule la case de départ (ainsi que le type de pièce dans certains cas) suffie. Cette notation abrégée est appelée SAN (Short Algebraic Notation).


\section{Architecture générale}

\subsection{Présentation générale}
Notre architecture s'articule autour de trois éléments principaux. Tout d'abord, nous utilisons différentes ressources afin d'obtenir des informations sur les coups à jouer. Ces ressources sont de trois types, chaque type étant associé à une phase du jeu. Les débuts de parties (les 5 à 10 premiers coups) sont répertoriés dans des bases de données appelées base de données d'ouverture (Openings Databases). Les informations accessibles via ce type de ressource sont essentiellement de natture statistiques, basées sur l'archivage de parties d'échecs. Ensuite, le milieu de partie est essentiellement dominé par des robots (appelés bots). Les informations communiquées par ces bots sont plutôt de nature calculatoire. Enfin, lorsqu'il ne reste plus que quelques pièces (5-6 généralement) sur l'échiquier, il existe des tables permettant de mener le joueur vers le meilleur résultat possible. Les ressources donnant accès à ces tables sont appelées Endings Databases. Ces tables sont de nature déterministe.

Toutes ces différentes ressources sont utilisées par un serveur central. Ce serveur central envoie des requêtes afin de récupérer différentes informations communiquées par les ressources puis sélectionne le meilleur coup. Le développement de ce serveur central est le coeur de cette étude pratique.

Une fois le meilleur coup déterminé par le serveur, celui-ci l'envoie aux clients (programmes d'échecs) ayant auparavant solicité le serveur afin d'avoir sa réponse sur le coup à jouer. Deux clients ont d'ailleurs été développés dans le cadre de cette étude pratique.
\FigureEPS{h,t,b,p}{12cm}{./ArchitectureSimple.eps}
{Schéma général du système}   
{fig:schema-systeme}

\subsection{Interfaces intermédiaires pour les ressources distantes}
Afin d'accéder à des ressources non accessibles en REST, nous avons dû mettre en place des interfaces intermédiaires en PHP. Ces interfaces ayant toutes des fonctions communes, nous avons choisi de créer un framework, en PHP également. Dans ce framework, nous communiquons avec les ressources au moyen d'appel cURL. Nous faisons donc des requêtes GET, éventuellement POST si requis, à chaque ressource. Le fait d'avoir centralisé le code nous permet également de structurer les appels pour respecter l'architecture REST. Toutefois les ressources n'utilisent pas toutes les mêmes conventions et les coups ne sont pas tous donnés sous la même forme. C'est pourquoi on trouve un ou plusieurs parser dans chaque interface intermédiaire. Ces parser permettent de formater les réponses des ressources. Comme nous avions besoin de transmettre peu d'informations, nous avons choisi de transmettre les réponses au format JSON, qui est peu verbeux. Ainsi, le serveur reçoit toutes les réponses dans un format unique.

\subsection{Conversions entre les formats}
Certaines ressources attendent des FEN sous une forme réduite, d'autres sous la forme normale; elles renvoient les suggestions de coups parfois au format SAN, parfois au format LAN. De plus les clients, pour leur interface graphique, ont parfois besoin du format LAN et parfois du format SAN. Nous avons donc dû implémenter les algorithmes, dans le serveur central, pour effectuer toutes les conversions nécessaires entre ses différents formats. Nous sommes partis pour cela d'algorithmes disponibles en JavaScript sur le site d'une de nos ressources. Nous avons donc dû les implémenter en Java, les améliorer et les corriger.

Ce code source étant assez complexe nous avons choisis d'utiliser les techniques de développement pilotés par les tests. Nous avons donc commencé par écrire des tests unitaires de nos conversions. Après avoir écrit une première version fonctionnelle, nous nous sommes attachés à améliorer les algorithmes. Cette méthode nous a permis de repérer relativement rapidement les erreurs déjà présentes dans le code JavaScript.


\section{Architecture du serveur central}

\subsection{Réprésentation des ressources côté serveur}
Nous avons rapidement déterminé trois types de ressources : les bases de données d'ouvertures, de fermeture et les moteurs d'échec.
Ces trois types de ressources ne nous renvoient pas les mêmes informations. Par exemple, les bases de données d'ouvertures nous renvoient des probabilités de gagner et de perdre ainsi que le nombre de fois que le coup proposé a été joué. Les moteurs d'échec nous renvoient, eux, la profondeur de calcul dans leur arbre de décision ainsi que le score associés à chaque coups.
Nous avons donc contruit nos classes Java sur ce modèle.
\FigureEPS{h,t,b,p}{15cm}{./resources-uml.eps}
{Diagramme UML des ressources côté serveur}   
{fig:diagramme-uml}

\subsection{Base de données SQLite}
Pour chaque ressource, seulement quelques informations doivent être enregistrées telles que l'URL, le nom ou la confiance dans la ressource (cf \label{TODO}). Toutes les ressources, quel que soit leur type, sont enregistrées dans la table Resources. Les utilisateurs du serveur central peuvent aussi créer des parties avec des informations associées concernant le format des réponses. Nous avons donc pour cela besoin d'une seconde table Games. Enfin, les coups proposés par les ressources et sélectionnés par le programme doivent aussi être stockés (cf \label{TODO}). Ces coups s'incrivent dans une partie et sont donc liés à la fois à Resources et à Games. Nous avons donc besoin d'une dernière table Moves.

\FigureEPS{h,t,b,p}{15cm}{./bdd-modele-conceptuel.eps}
{Modèle entité-association de la base de données}   
{fig:modele-bdd}

Pour réaliser cette base de données nous avons choisi d'utiliser le moteur de bases de données SQLite. En effet, ce dernier s'adapte particulièrement à de petites bases de données comme dans notre cas puisqu'il ne suit pas le schéma habituel serveur-client. Les informations sont stockées dans un seul fichier et les accès sont très rapides.

Pour permettre à l'utilisateur de configurer simplement le système nous avons réalisé une interface graphique qui permet essentiellement d'ajouter, d'éditer ou de supprimer les ressources de la base de données. L'interface est réalisée avec la bibliothèque pour Java open-source et multiplateforme, SWT. Elle permet aussi de configurer le système, les pondérations (cf \label{TODO}) et de lancer le serveur central.

\subsection{Utilisation des ressources}
Au démarrage, le serveur central commence par vérifier la disponibilité des ressources. Seulement les ressources qui répondent à cette première requête et qui possèdent une version compatible sont gardées pour la suite.
A chaque appel du serveur central par le client, toutes les ressources sont interrogées pour obtenir une liste de suggestions de coups associés à la position de l'échiquier envoyée. Les ressources répondent ensuite avec un document JSON contenant tous les coups et leurs informations associées. Ce document est convertit en une liste d'objets Java MoveSuggestion (OpeningSuggestion pour les bases de données d'ouverture, etc.).
Les requêtes vers chaque ressources ainsi que la conversion en objets Java sont effectués en parallèle avec l'utilisation de threads.

\subsection{Interface RESTful du serveur central}
Pour effectuer les appels vers les ressources et surtout pour créer l'interface RESTful de notre serveur central nous avons choisi d'utiliser Jersey. Ce framework implémente l'interface de programmation Java \textit{Java API for RESTful Web Services} (JAX-RS) qui permet de créer des services web avec une architecture REST.

La première requête que doivent effectuer les clients qui souhaitent utiliser le serveur central est une requête HTTP POST pour créer la partie sur le serveur. Ils peuvent alors en profiter pour dire quel format de coups d'échec il souhaitent recevoir par la suite. Pour la suite de la partie, à chaque fois qu'un client veut l'avis du serveur central, il lui envoie l'état de l'échiquier sous forme de FEN avec une requête HTTP GET. A la fin de la partie, le client doit envoyer une requête HTTP DELETE avec le FEN final pour que le serveur central puisse mettre à jour la base de données et récompenser les ressources en fonction de l'issue de la partie (cf \label{TODO}).

Nous avons aussi ajouter la possibilité d'interroger le serveur central directement sans créer préalablement de partie, pour permettre aux utilisateurs de tester rapidement. Dans cette hypothèse, sans suivi de la partie, le système ne pourra pas évoluer de manière autonome. Enfin, nous avons mis à disposition une URL pour pouvoir analyser le fonctionnement interne. Lorsque cette dernière est utilisée pour récupérer l'avis du serveur central, les informations ayant servi aux calculs sont affichées.

\subsection{Listeners du serveur central}
Nous avons créé trois listeners pour que le serveur central puisse les notifier de tous les évènements qui ont lieu. Le premier listener est avertit de tous les accès qui sont fait au serveur depuis les clients. Le second est notifié lors des accès à la base de données ainsi que lors des exceptions levées. Le dernier listener est appelé pour tous les évènements liés aux ressources, à la fois lorsqu'on les interroge et lorsqu'elles nous répondent.
Cette façon de faire permettra à la personne qui reprendra notre code de développer une interface graphique plus complète que celle que nous avons fait en respectant le patron Modèle-Vue-Contrôleur.


\section{Clients graphique}
Afin de valoriser notre travail et de pouvoir tester de façon plus visuelle le système, nous avons interfacé deux clients graphiques avec notre serveur central. De part l'utilisation de l'architecture REST, notre système peut être interfacé avec n'importe quel client graphique. Nous avons juste dû, pour chaque client, écrire les fonctions pour effectuer les différentes requêtes HTTP vers l'interface RESTful du serveur central.

Le premier client avait été développé avec Unity 3D, nous avons donc dû écrire nos fonctions en C\#. Le second client était en JavaScript (et fonctionne donc sur mobile) et nous avons donc utilisé l'architecture AJAX pour effectuer les requêtes vers le serveur central. L'architecture AJAX utilise quelques requêtes particulières, appelées preflight (\label{TODO: site externe}). Cela nous a contraint a adapter l'interface RESTful du serveur central.


\section{Classement des suggestions de coups}

	Les ressources seules ne permettent pas de choisir directement qeul coup renvoyer au client. En effet, nous devons renvoyer un unique coup (considéré comme étant le meilleur) au client, mais les ressources interrogées nous en conseillent généralement plusieurs.
De ce fait, nous avons donc créé un système permettant de renvoyer le meilleur coup (ou du moins considéré comme tel) au client, en tenant compte des informations renvoyées par les ressources et en intégrant les parties précédemment jouées.

\subsection{Calcul d'un score}
Comme nous l'avons vu au point (TODO), il existe différents types de ressources nous communiquant différant types d'informations.
Cependant, toutes les ressources nous renvoient au moins un coup ainsi que plusieurs informations sur ce coup (la probabilité de gagner et le nombre de fois que le coup a été joué pour les bases d'ouvertures et la profondeur de recherche ainsi que le score attribué au coup pour les bots).

Partant du fait que nous avions pour chaque coups des informations justifiant son choix, nous avons donc décidé de calculer notre propre score associé à ce coup. Ainsi nous réutilisons les informations données par les ressources pour faire notre propre classement des meilleurs coups à jouer (le score renvoyé par les bots ne sera pas le score associé à ce coup, mais simplement une information).
Notre première idée a donc été de sommer les différentes informations afin d'obtenir le score associé. Cependant, toutes les informations n'ont pas le même poids. En effet, par exemple, on peut penser que le score associé par un bot est plus ou moins important par rapport à la profondeur de recherche. Ces différentes pondérations (\(a_{k}\)) sont choisies par l'utilisateur via la GUI. Ainsi, c'est lui qui détermine quelle information privilégier. 

Nous avons donc \(Score(coup_{i})_{ressource_{j}}=\sum_{k=1}^na_{k}*f_{k}(x_{k})\) avec \(x_{k}\) la kième information donnée par la ressource sur le \(coup_{i}\) et \(f_{k}\) la fonction de traitement associée à l'information \(x_{k}\) (Voir section suivante pour la définition de \(f_{k}\) ).

Le score calculé précédemment est valable pour un coup proposé par une ressource. Généralement, chaque coup est proposé par plusieurs ressources. Pour obtenir le score total d'un coup, nous avons simplement effectué une somme pondérée des scores (sur les ressources) associé à ce coup. Les pondérations sont liées au fait que l'on fait plus ou moins confiance à chaque ressource. Par exemple, une base de données d'ouverture contenant les parties des plus grands maîtres d'échecs sera plus digne de confiance qu'une base contenant des parties de tournois amateurs. De plus, les pondérations des informations (les \(a_{k}\)) sont spécifiques à chaque type de ressource. En effet, les informations communiquées sont différentes en fonction du type de ressource et donc les pondérations sont également différentes. Nous avons donc la contrainte \(\sumk_{k=1}^na_{k}=1\) afin que les ressources puissent être comparées entre elles.

Nous avons donc la formule suivante :\\ \(Score(coup_{i})=\sum_{k=1}^mT_{k}*Score(coup_{i})_{ressource_{k}}\) avec \(T_{k}\) la confiance accordée à la ressource k.

Ensuite, une fois ces scores calculés pour chaque coup, nous choisissons le coup ayant le score maximal. Ce coup est considéré comme étant le meilleur et est renvoyé au client.

\subsection{Statistiques}
Comme nous l'avons vu précédemment, les informations subissent des traitements (les fonctions \(f_{k}\)) avant d'être agrégées (via la somme). Ces traitements visent essentiellement à rendre comparable les différentes informations obtenues. En effet celles-ci se situent généralement dans des échelles différentes (une probabilité est entre 0 et 1 alors que le nombre de coup joué est potentiellement très élevé). Pour pouvoir mettre les informations à la même échelle nous centrons puis nous réduisons les variables \(x_{k}\) à l'aide des fonctions f associées.

Nous avons donc :\\ \(f_{k}(x_{k})=\frac{x_{k}-\bar{x_{k}}}{\vee(x_{k})}\).

Afin d'obtenir ces statistiques, nous avons donc créé une classe qui s'occupe de gérer et de recalculer après chaque coup les statistiques liées aux différentes informations.

\subsection{Evolution des pondérations}
Le système décrit précédemment permet de bien prendre en compte la diversité des informations ainsi que l'hétérogénéité des ressources mais il reste encore figé. Pour rendre dynamique notre système, nous avons donc fait un système permettant de recalculer à chaque fin de partie la confiance que nous avons dans chaque ressource.

Le principe de l'évolution de la confiance est basé sur un système de récompense. Si nous gagnons la partie, toutes les ressources nous ayant proposés au moins un coup joué lors de la partie seront récompensées positivement. Si nous perdons, elle le seront négativement et en cas de match nul, le système n'évolue pas. De plus, la récompense est proportionnelle à la confiance qu'avait la ressource dans le coup proposé. Plus elle est confiante, plus sa récompense augmente.

Ainsi, nous avons donc un système qui permet d'utiliser les parties passées (via les statistiques et via la confiance dans les ressources) et les différentes informations communiquées par les ressources pour déterminer le meilleur coup à jouer.
Ce système peut néanmoins être améliorer, notamment pour intégrer une notion de ressemblance entre les ressources. En effet, si deux ressources identiques ou se basant sur des données identiques sont appelées (notre système les considère comme différentes), il additionnera les scores associés aux coups proposés par ces ressources, sans s'apercevoir qu'elles sont en fait très proches. Le principe serait donc de calculer une "distance" entre les différentes ressources afin d'atténuer une ressource si une autre ressource "proche" a déjà été prise en compte.


\section{Conclusion} 
 


\bibliography{biblio-rapport}

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
