%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     STYLE POUR LES EXPOSES TECHNIQUES 
%         3e année INSA de Rennes
%
%             NE PAS MODIFIER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,11pt]{article}

\usepackage{exptech}       % Fichier (./exptech.sty) contenant les styles pour 
                           % l'expose technique (ne pas le modifier)

%\linespread{1,6}          % Pour une version destinée à un relecteur,
                           % décommenter cette commande (double interligne) 
                           
% UTILISEZ SPELL (correcteur orthographique) à accès simplifié depuis XEmacs

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{ \textbf{Rapport\\Distributed Chess Service} }
\markright{Style pour l'exposé technique} 
                           % Pour avoir le titre de l'expose sur chaque page

\author{Paul \textsc{Chaignon}, Thomas \textsc{François}, \\
        Damien \textsc{Le Guen}, Clément \textsc{Gautrais}, \\
				Benoit \textsc{Travers} \\
        \\
        Encadreur : Yann \textsc{Ricquebourg}}

\date{}                    % Ne pas modifier
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}          

\maketitle                 % Génère le titre
\thispagestyle{empty}      % Supprime le numéro de page sur la 1re page



\begin{abstract}


Le résumé est limité à 10 lignes au maximum.
\end{abstract} 


\section{Introduction}  

[TODO: Attentes de Loic Helouet.]
[TODO: Spécifications en boîte noire.]


\section{Architecture}

\subsection{Présentation générale}
[TODO: Présenter le fonctionnement général du système.]

\subsection{Interfaces intermédiaires pour les ressources distantes}
Afin d'accéder à des ressources non accessibles en REST, nous avons dû mettre en place des interfaces intermédiaires en PHP. Ces interfaces ayant toutes des fonctions communes, nous avons choisi de créer un framework, en PHP également. Dans ce framework, nous communiquons avec les ressources au moyen d'appel cURL. Nous faisons donc des requêtes GET, éventuellement POST si requis, à chaque ressource. Le fait d'avoir centralisé le code nous permet également de structurer les appels pour respecter l'architecture REST. Toutefois les ressources n'utilisent pas toutes les mêmes conventions et les coups ne sont pas tous donnés sous la même forme. C'est pourquoi on trouve un ou plusieurs parser dans chaque interface intermédiaire. Ces parser permettent de formater les réponses des ressources. Comme nous avions besoin de transmettre peu d'informations, nous avons choisi de transmettre les réponses au format JSON, qui est peu verbeux. Ainsi, le serveur reçoit toutes les réponses dans un format unique.

\subsection{Réprésentation des ressources côté serveur}
Nous avons rapidement déterminé trois types de ressources : les bases de données d'ouvertures, de fermeture et les moteurs d'échec.
Ces trois types de ressources ne nous renvoient pas les mêmes informations. Par exemple, les bases de données d'ouvertures nous renvoient des probabilités de gagner et de perdre ainsi que le nombre de fois que le coup proposé a été joué. Les moteurs d'échec nous renvoient, eux, la profondeur de calcul dans leur arbre de décision ainsi que le score associés à chaque coups.
Nous avons donc contruit nos classes Java sur ce modèle.
[TODO: UML]

\subsection{Base de données SQLite}
Pour chaque ressource, seulement quelques informations doivent être enregistrées telles que l'URL, le nom ou la confiance dans la ressource (cf \label{TODO}). Toutes les ressources, quel que soit leur type, sont enregistrées dans la table Resources. Les utilisateurs du serveur central peuvent aussi créer des parties avec des informations associées concernant le format des réponses. Nous avons donc pour cela besoin d'une seconde table Games.
[TODO: Schémas de conception, justification du choix de SQLite.]

\subsection{Utilisation des ressources}
Au démarrage, le serveur central commence par vérifier la disponibilité des ressources. Seulement les ressources qui répondent à cette première requête et qui possèdent une version compatible sont gardées pour la suite.
A chaque appels du serveur central par le client, toutes les ressources sont interrogées pour obtenir une liste de suggestions de coups associés à la position de l'échiquier envoyée. Les ressources répondent ensuite avec un document JSON contenant tous les coups et leurs informations associées. Ce document est convertit en une liste d'objets Java MoveSuggestion (OpeningSuggestion pour les bases de données d'ouverture, etc.).
Les requêtes vers chaque ressources ainsi que la conversion en objet Java sont effectués en parallèle avec l'utilisation de threads.

\subsection{Interface RESTful du serveur central}
[TODO: Interface Jersey : les requêtes HTTP requises.]

\subsection{Listeners du serveur central}
[TODO: Listeners]


\section{Classement des suggestions de coups}

	Les ressources seules ne permmettent pas de choisir directement qeul coup renvoyer au client. En effet, nous devons renvoyer un unique coup (considéré comme étant le meilleur) au client, mais les ressources interrogées nous en conseillent généralement plusieurs.
De ce fait, nous avons donc créé un système permettant de renvoyer le meilleur coup (ou du moins considéré comme tel) au client, en tenant compte des informations renvoyées par les ressources, tout en tenant compte des parties précédemment jouées.

\subsection{Calcul d'un score}
Comme nous l'avons vu au point (TODO), il existe différents types de ressources nous communiquant différant types d'informations.
Cependant, toutes les ressources nous renvoient au moins un coup ainsi que plusieurs informations sur ce coup (la probabilité de gagner et le nombre de fois que le coup a été joué pour les bases d'ouvertures et la profondeur de recherche ainsi que le score attribué au coup pour les bots).
Partant du fait que nous avions pour chaque coups des informations justifiant son choix, nous avons donc décidé de calculer notre propre score associé à ce coup. Ainsi nous réutilisons les informations données par les ressources pour faire notre propre classement des meilleurs coups à jouer (le score renvoyé par les bots ne sera pas le score associé à ce coup, mais simplement une information).
Notre première idée a donc été de sommer les différentes informations afin d'obtenir le score associé :
\[Score(coup1)=\sum_{k=1}^nx_{k}\] avec \[x_{k}\] la kième informations données par la ressource sur le coup1.
[TODO: Formule générale avec somme pour différentes suggestions.]

\subsection{Statistiques}
[TODO: Amélioration de la formule avec variance et moyenne (centrée réduite).]

\subsection{Evolutuion des pondérations}
[TODO: Evolution automatique des pondérations.]


\section{Conclusion} 
 



\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
