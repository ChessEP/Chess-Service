\documentclass[a4paper,11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{listings}

\title{Distributed Chess Services - Guide d'utilisation}
\author{P. Chaignon, C. Gautrais, T. François, D. Le Guen, B. Travers}
\date{INSA Rennes - 2012-2013} 


\begin{document}
\maketitle{}

{\em Ce guide vous apprendra à utiliser le Distributed Chess Services afin d'ajouter à un projet de jeu d'échecs une intelligence artificielle distante. Deux aspects seront abordés : la connexion d'un jeu avec le service distant et, dans un deuxième temps, l'ajout et la modification de base de connaissances au service}


\section*{Contexte}
        Afin de simuler une intelligence artificielle de jeu d'échecs, il existe de nombreuses ressources disponibles. Celles-ci prennent la forme de bases de connaissances répertoriant les meilleurs coups à jouer d'après les parties d'échecs de grands champions, ainsi que de nombreux bots (robots) pouvant, à partir d'une situation d'échiquier donnée, choisir le coup suivant le plus efficace. Cependant, inclure toutes ces ressources au sein même du jeu peut se révéler délicat. Cela nécessite en effet une mise à jour du programme dès la moindre modification des informations. Et ce genre de recherche demandant une puissance de calcul importante de la part de la plateforme, le portage du logiciel sur une plateforme moins puissante (notamment mobile) devient un casse-tête d'optimisation.
        
        Déléguer cette partie du jeu d'échecs à un service tiers peut constituer une solution élégante. Ce service distant fait office de serveur centralisant toutes les opérations de recherche et de calculs. Un jeu d'échecs (ici en position de client) pourra envoyer à ce serveur une requête web et obtenir en retour le meilleur coup à jouer. En plus de libérer le client de la lourde tâche de calculs (permettant ainsi le portage théorique sur toute plateforme disposant d'une simple connexion Internet), cela permet aussi de garder un certain contôle sur l'accès des joueurs aux données. Et ainsi tirer des statistiques sur la performance des algorithmes mis en place.


[placer ici un schéma global de l’archi]


\chapter{Déployer le serveur central}

[TODO: Les étapes basiques pour lancer le serveur central et lui ajouter les trois ressources qu'on a développé : lancer le serveur central, déployer les ressources déjà existantes et les ajouter au serveur central.]



\chapter{Interfaçage client et serveur central}
        On supposera l'existence préalable du programme capable de gérer la logique et les règles du jeu d'échecs (déplacement correct des différentes pièces, connaissance du joueur devant jouer le prochain coup, reconnaissance des situtaions particulières telles que l'échec et l'échec et mat...) ainsi que de l'aspect graphique du plateau. Prenons le cas d'un logiciel sachant déjà gérer une partie d'échecs entre deux joueurs humains en local. L'ajout d'un mode humain contre ordinateur s'effectuera en remplaçant la logique de jeu du deuxième joueur par l'envoi de requêtes au serveur central via une adresse respectant l’architecture REST. 


\section{Création d’une partie}
        Au démarrage de la partie, il est nécessaire d’envoyer au serveur une première requête visant à authentifier le jeu et lui allouer un identificateur (GameID) unique. Il y a deux intérêts à effectuer cette requête. Le premier est de pouvoir ainsi suivre et enregistrer le déroulement de la partie du côté serveur et pouvoir établir en fin de partie des statistiques sur les ressources ayant donné les meilleurs résultats. Le deuxième intérêt est qu’il est possible de paramétrer le format de réception des coups à jouer. En effet, certains clients préfèrent recevoir le coup en notation algébrique longue (LAN), par exemple {\tt e2e4} pour un pion ou {\tt b1c3} pour un cavalier ; tandis que d’autres attendent une notation alébrique courte (SAN), les exemples précédents deviennent {\tt e4} et {\tt Nc3}.


        L’appel à envoyer est alors une simple requête POST à l’adresse du serveur, prenant comme donnée d’envoi un booléen indiquant si le format de retour doit être au format SAN ou non.
\\{\tt POST http://localhost:9998/rest\\
PostData : {\em san=false}\\
Return : Integer {\em (par exemple : 1234)} }\\


\section{Obtenir le prochain coup à jouer}
        Dès que le joueur humain aura effectué son déplacement de pièce, une requête GET doit alors être envoyé au serveur. Cette URI nécessite deux informations : le GameID obtenu par la première requête POST et l'état actuel de l'échiquier au format normalisé FEN (pour Forsyth-Edwards Notation). Prenons ici par exemple ce code FEN: 
\\{\tt rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR {\bf b} KQkq - 0 1}\\
Celui-ci est divisé en trois sections principales :
\begin{itemize}
   \item La première partie, la plus longue, la position de chaque pièce sur le plateau. Ici, l'échiquier est en position de départ à l'exception du pion devant le roi blanc, qui a avancé de 2 cases.
   \item Le '{\bf b}' indique que c'est aux noirs (black) de jouer.
   \item Les derniers caractères contiennent plusieurs informations propres aux règles specifiques des échecs (tels que le roque ou le coup du pion en passant) et ne seront pas détaillés dans ce guide. Pour plus de détails sur le système FEN, des liens sont disponibles en fin de guide 
\end{itemize}
        Pour un envoi correct, les slashes '/' et les espaces présents dans le code FEN devront être modifiés respectivement par des symboles dollars '\$' et par le code HTML de l'espace, '\%20'. Ainsi le FEN précédent devra être modifié de la façon suivante :
\\{\tt rnbqkbnr\$pppppppp\$8\$8\$4P34\$8\$PPPP1PPP\$RNBQKBNR\%20b\%20KQkq\%20-\%200\%201}
        
        Comme nous l’avons vu précedemment, la réponse du serveur est reçu en notation algébrique longue ou courte (LAN ou SAN) selon le paramétrage effectué. Ainsi, avancer de deux cases le pion blanc placé en e4 s'écrira {\tt e4e6}.
\\{\tt GET http://localhost:9998/rest/{\em GameID}/{\em FEN}\\
Return : String {\em (par exemple : "e4e6")} }\\
        


\section{Fin de partie}
        Une fois la partie d’échecs terminée, il est important d’envoyer une requête DELETE afin que le serveur puisse effectuer en interne des valorisations ou dévaluations des ressources ayant influé en bien ou en mal sur l’issue de la partie et effacer l’ID de la base de données. Cette requête DELETE attend les mêmes informations que la requête GET précédente : 
\\{\tt DELETE http://localhost:9998/rest/{\em GameID}/{\em FENfinal}}


\chapter{Ajout de ressources au serveur central}
         Dans le cadre d'un jeu d'échecs, il est rapidement possible d’être amené à vouloir déployer et modifier ses propres ressources (bots et bases de données de coups) afin de paramétrer au mieux le choix des coups par le serveur.
        
[TODO: Comment déployer de nouvelles ressources : utilisation du framework et parseur vers JSON.]
        
        

\end{document}
